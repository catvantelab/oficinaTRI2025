# Primeira aplicação

```{r, echo=FALSE, include=FALSE}
library(mirt)
library(ggplot2)
library(data.table)
library(dplyr)
library(lordif)
library(cowplot)
library(mirtCAT)
devtools::load_all()
```

## Preparação

Importar banco

```{r}
data(banco2pl.t1, package = 'oficinaTRI2025')
```

Nome das variáveis do banco

```{r}
names(banco2pl.t1)
```

São 50 itens. Confirmar que os itens são dicotômicos

```{r}
table(banco2pl.t1$Item_1)
```

Função apply para toda a tabela (quando usa 2, a função percorre cada coluna).

```{r}
apply(banco2pl.t1, 2, table)
```
## Calibração inicial

Calibrar os itens no modelo logístico de dois parâmetros

```{r}
fit.t1 <- mirt(data = banco2pl.t1, model = 1, itemtype = '2PL', TOL = .001)
```

Verificar os parâmetros dos itens

```{r}
head(coef(fit.t1))
```

Verificar os parâmetros dos itens de forma simplificada

```{r}
coef(fit.t1, simplify = TRUE)
```

Verificar os parâmetros dos itens na TRI (dificuldade em vez do intercepto) de forma simplificada

```{r}
coef(fit.t1, IRTpars = TRUE, simplify = TRUE)
```

Armazenar os parâmetros em um objeto

```{r}
pars.t1 <- data.frame(coef(fit.t1, IRTpars = TRUE, simplify = TRUE)$items)
pars.t1
```

## Inspeção inicial

Curva de informação do teste

```{r}
plot(fit.t1, type = 'info')
```

Erro padrão de medida em função do escore

```{r}
plot(fit.t1, type = 'SE')
```

Informação do teste e erro padrão

```{r}
plot(fit.t1, type = 'infoSE')
```

Curva característica de cada item

```{r}
plot(fit.t1, type = 'trace')
```

## Escore dos sujeitos

Calcular o escore dos sujeitos e o erro de medida

```{r}
escore.t1 <- data.frame(fscores(object = fit.t1, full.scores.SE = TRUE))
head(escore.t1)
```

## Erro e informação

Gráficos com a curva de densidade da amostra, informação do teste e erro de medida na calibração T1.

```{r densidade_1}

info_t1 <- testinfo(fit.t1, seq(-3, 3, .01))

grafico_t1_info <- ggplot() +
  geom_density(aes(x = escore.t1$F1)) +
  labs(title='Densidade e informação (T1)', x= "escore", y = "densidade") +
  geom_line(aes(x = seq(-3, 3, .01), y = info_t1 / 45), linetype = 2) +
  scale_y_continuous(limits = c(0, 1),
                     sec.axis = sec_axis(~ . * 45, name = 'informação'))

erro_t1 <- 1/sqrt(info_t1 + 1)

grafico_t1_erro <- ggplot() +
  geom_density(aes(x = escore.t1$F1)) +
  labs(title='Densidade e erro (T1)', x= "escore", y = "densidade") +
  geom_line(aes(x = seq(-3, 3, .01), y = erro_t1 / .8), linetype = 2) +
  scale_y_continuous(limits = c(0, 1),
                     sec.axis = sec_axis(~ . * .8, name = 'erro padrão'))

plot_grid(grafico_t1_info, grafico_t1_erro,
          labels = c('A', 'B'),
          ncol = 2)

```

Conclusão: existe uma lacuna no instrumento para medir bem os sujeitos com maior magnitude do traço latente. Precisamos ampliar nosso banco com itens mais difíceis.

# Segunda aplicação

## Preparação

Importar banco

```{r}
data(banco2pl.t2, package = 'oficinaTRI2025')
```

Nome das variáveis do banco

```{r}
names(banco2pl.t2)
```

São 50 itens. Confirmar que os itens são dicotômicos

```{r}
apply(banco2pl.t2, 2, table)
```

## Calibração dos novos itens

Calibrar os itens no modelo logístico de dois parâmetros

```{r}
fit.t2 <- mirt(data = banco2pl.t2, model = 1, itemtype = '2PL', TOL = .001)
```
Armazenar os parâmetros em um objeto

```{r}
pars.t2 <- data.frame(coef(fit.t2, IRTpars = TRUE, simplify = TRUE)$items)
pars.t2
```

Problema: a referência da escala da calibração T2 é diferente da referência da calibração T1. Portanto as medidas T1 e T2 não são comparáveis. Uma solução é fixar os parâmetros dos itens comuns.

Primeiro, é preciso gerar a tabela de parâmetros inicial para configurar esses parâmetros. Para isso, usamos o argumento `pars`.

```{r}
tab.pars <- mirt(data = banco2pl.t2, model = 1, itemtype = '2PL', TOL = .001, pars = 'values')
head(tab.pars)
```

Agora, vamos atribuir os valores obtidos na calibração inicial. Um caminho é obter esses valores a partir da tabela de parâmetros final da calibração inicial e incluí-los no objeto `tab.pars`.

Primeiro, criar objeto com nome dos itens comuns e obter a tabela de parâmetros final da calibração inicial.

```{r}
itens.comuns <- paste0('Item_', 21:50)
pars.comuns <- mod2values(fit.t1)
```

Em seguida, fazer um loop para atribuir os valores dos parâmetros.

```{r}
for(i in 1:length(itens.comuns))
{
  tab.pars[tab.pars$item == itens.comuns[i] & tab.pars$name == 'a1', 'value'] <- pars.comuns[pars.comuns$item == itens.comuns[i] & pars.comuns$name == 'a1', 'value']
  tab.pars[tab.pars$item == itens.comuns[i] & tab.pars$name == 'd', 'value'] <- pars.comuns[pars.comuns$item == itens.comuns[i] & pars.comuns$name == 'd', 'value']
  tab.pars[tab.pars$item == itens.comuns[i], 'est'] <- FALSE
}
```

Na nova calibração de T2, note a diferença no argumento `pars`.

```{r, eval=FALSE}
fit.t2 <- mirt(data = banco2pl.t2, model = 1, itemtype = '2PL', TOL = .001, pars = tab.pars)
```
A calibração rodou, porém está incorreta. Por padrão, a o `mirt` fixa a média do grupo de referência da calibração em `0` e o desvio padrão, em `1`. Veja esses valores obtidos na primeira calibração:
```{r}
coef(fit.t1, simplify = TRUE)$means
coef(fit.t1, simplify = TRUE)$cov
```
Isso significa que na calibração T1 os itens foram calibrados tendo o grupo T1 como referência. O centro da escala (`0`) é a média do grupo T1. Ocorre que na calibração T2, o `mirt` também fixou a média do grupo em `0`. Ou seja, se fixarmos a média do grupo T2 na calibração, esse grupo é tratado como a referência da escala. Porém, a referência deve ser o grupo T1, cuja média é o centro da escala. Portanto, para mantermos a referência correta, é preciso liberar a estimação da máedia e do desvio padrão do grupo T2 na calibração. Isso é feito na tabela de parâmetros inicial da calibração T2.

Em resumo, na calibração T2 é preciso fixar os itens comuns e liberar a média e o desvio do grupo T2. O complemento do comando para tratar a tabela de parâmetros é esse:

```{r}

tab.pars[tab.pars$name == 'MEAN_1', 'est'] <- TRUE
tab.pars[tab.pars$name == 'COV_11', 'est'] <- TRUE

```

Agora sim, a calibração T2.
```{r}
fit.t2 <- mirt(data = banco2pl.t2, model = 1, itemtype = '2PL', TOL = .001, pars = tab.pars)
```

## Análise de DIF

Nesta atividade, vamos usar o método do Root Mean Square Deviation (RMSD, Raiz do Desvio Quadrático Médio). A função `RMSD_DIF` no pacote `mirt` implementa o método, porém somente para objetos do tipo `MultipleGroupClass`, gerado pela função `multipleGroup`. Como o nosso objeto é `SingleGroupClass`, adaptei a função. O critério utilizado nesta atividade para marcar itens com DIF é `0.10`.

```{r}
dif.rmsd(calib = fit.t2, flag = 0.10)
```

Conclusão: não foi detectado DIF com o método RMSD.

## Escore dos sujeitos

Calcular o escore dos sujeitos e o erro de medida

```{r}
escore.t2 <- data.frame(fscores(fit.t2, full.scores.SE = TRUE))
head(escore.t2)
```

## Erro e informação

Gráficos com a curva de densidade da amostra, informação do teste e erro de medida na calibração T2.

```{r densidade_1}

info_t2 <- testinfo(fit.t2, seq(-3, 3, .01))

grafico_t2_info <- ggplot() +
  geom_density(aes(x = escore.t2$F1)) +
  labs(title='Densidade e informação (T2)', x= "escore", y = "densidade") +
  geom_line(aes(x = seq(-3, 3, .01), y = info_t2 / 45), linetype = 2) +
  scale_y_continuous(limits = c(0, 1),
                     sec.axis = sec_axis(~ . * 45, name = 'informação'))

erro_t2 <- 1/sqrt(info_t2 + 1)

grafico_t2_erro <- ggplot() +
  geom_density(aes(x = escore.t2$F1)) +
  labs(title='Densidade e erro (T2)', x= "escore", y = "densidade") +
  geom_line(aes(x = seq(-3, 3, .01), y = erro_t2 / .8), linetype = 2) +
  scale_y_continuous(limits = c(0, 1),
                     sec.axis = sec_axis(~ . * .8, name = 'erro padrão'))

plot_grid(grafico_t2_info, grafico_t2_erro,
          labels = c('A', 'B'),
          ncol = 2)

```


Comparação da informação e erro em T1 e em T2.

Curva de densidade da amostra e de informação do teste (Primeira aplicação)

```{r}

ggplot() +
  geom_density(aes(x = escore.t1$F1)) +
  labs(title='Densidade da amostra e informação do teste', x= "escore", y = "densidade") +
  geom_line(aes(x = seq(-3, 3, .01), y = info / 45), linetype = 2) +
  scale_y_continuous(limits = c(0, 1),
                     sec.axis = sec_axis(~ . * 45, name = 'informação'))
```

Curva de densidade da amostra e de informação do teste (Segunda aplicação, Grupo T1)

```{r}

info <- testinfo(fit.t2, seq(-3, 3, .01))

ggplot() +
  geom_density(aes(x = escore.t1$F1)) +
  labs(title='Densidade da amostra e informação do teste', x= "escore", y = "densidade") +
  geom_line(aes(x = seq(-3, 3, .01), y = info / 45), linetype = 2) +
  scale_y_continuous(limits = c(0, 1),
                     sec.axis = sec_axis(~ . * 45, name = 'informação'))

```

Curva de densidade da amostra e do erro da medida (Segunda aplicação, Grupo T1)

```{r}
erro <- 1/sqrt(info + 1)

ggplot() +
  geom_density(aes(x = escore.t1$F1)) +
  labs(title='Densidade da amostra e erro de medida', x= "escore", y = "densidade") +
  geom_line(aes(x = seq(-3, 3, .01), y = erro / .8), linetype = 2) +
  scale_y_continuous(limits = c(0, 1),
                     sec.axis = sec_axis(~ . * .8, name = 'erro padrão'))
```

Curva de densidade da amostra e de informação do teste (Segunda aplicação, Grupo T2)

```{r}

# t2 <- extract.group(fit.t1.mg, 't2')
# info <- testinfo(t2, seq(-3, 3, .01))
# escore.t2 <- data.frame(fscores(t2))

ggplot() +
  geom_density(aes(x = escore.t2$F1)) +
  labs(title='Densidade da amostra e informação do teste', x= "escore", y = "densidade") +
  geom_line(aes(x = seq(-3, 3, .01), y = info / 45), linetype = 2) +
  scale_y_continuous(limits = c(0, 1),
                     sec.axis = sec_axis(~ . * 45, name = 'informação'))

```

Curva de densidade da amostra e do erro da medida (Segunda aplicação, Grupo T2)

```{r}

ggplot() +
  geom_density(aes(x = escore.t2$F1)) +
  labs(title='Densidade da amostra e erro de medida', x= "escore", y = "densidade") +
  geom_line(aes(x = seq(-3, 3, .01), y = erro / .8), linetype = 2) +
  scale_y_continuous(limits = c(0, 1),
                     sec.axis = sec_axis(~ . * .8, name = 'erro padrão'))
```

# Montagem do instrumento

O objetivo é montar um instrumento que meça com boa precisão um intervalo razoável da escala, entre `-1.5` e `1.5`.

Primeiro, criar tabela com o banco de itens e ordenar pelo intercepto (facilidade), que é o que o mirt usa
```{r}
pars.t1.mirt <- data.frame(coef(fit.t1, simplify = TRUE)$items)
pars.t2.mirt <- data.frame(coef(fit.t2, simplify = TRUE)$items)
pars.70 <- rbind(pars.t1.mirt, pars.t2.mirt[31:50,])
pars.70 <- arrange(pars.70, d)
head(pars.70)
```

Em seguida, selecionar 40 itens deslocando um pouco a seleção para os mais difíceis, e gerar um modelo mirt com a função `generate.mirt_object`.

```{r}
pars.final <- pars.70[ceiling(seq(1, 55, length.out = 40)),]

fit.final <- generate.mirt_object(parameters = pars.final, itemtype = '2PL')

```

Avaliar a curva de informação e de erro do teste final.

```{r}
info_final <- testinfo(fit.final, seq(-3, 3, .01))

grafico_info <- ggplot() +
  geom_density(aes(x = escore.t1$F1)) +
  labs(title='Densidade (T1) e informação (final)', x= "escore", y = "densidade") +
  geom_line(aes(x = seq(-3, 3, .01), y = info_final / 45), linetype = 2) +
  scale_y_continuous(limits = c(0, 1),
                     sec.axis = sec_axis(~ . * 45, name = 'informação'))

erro_final <- 1/sqrt(info_final + 1)

grafico_erro <- ggplot() +
  geom_density(aes(x = escore.t1$F1)) +
  labs(title='Densidade (T1) e erro (final)', x= "escore", y = "densidade") +
  geom_line(aes(x = seq(-3, 3, .01), y = erro_final / .8), linetype = 2) +
  scale_y_continuous(limits = c(0, 1),
                     sec.axis = sec_axis(~ . * .8, name = 'erro padrão'))

plot_grid(grafico_info, grafico_erro,
          labels = c('A', 'B'),
          ncol = 2)

```

Tente aprimorar o instrumento para atender ao objetivo de medir com boa precisão o intervalo entre `-1.5` e `1.5`. Em seguida, pense em outros usos e tente montar um instrumento que atenda a esses objetivos.
